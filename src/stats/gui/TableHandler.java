/* ----------------------------------------------------------------------------
 * File: TableHandler.java
 * Date: May 16th, 2013
 * ----------------------------------------------------------------------------
 */
package stats.gui;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.plaf.metal.MetalBorders;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import stats.core.*;
import static stats.core.DataType.*;

/**
 *
 * @author marco
 */
public class TableHandler extends javax.swing.JPanel {

  /**
   * Table object holding data.
   */
  private stats.core.Table table;

  /**
   * Read-only status of the TableHandler object.
   */
  private boolean isEditable;

  /**
   * The JTable object showing data contained in table object.
   */
  private javax.swing.JTable main_table;

  /**
   * The JTable object showing row numbers.
   */
  private javax.swing.JTable row_table;

  /**
   * Row selection status.
   */
  private ListSelectionModel row_selectionModel;

  /**
   * Column selection status.
   */
  private ListSelectionModel col_selectionModel;

  /**
   * Foreground color of table headers.
   */
  private static Color header_forecolor = new Color(0, 0, 0);

  /**
   * Background color of unselected row and column headers.
   */
  private static Color header_unselected_color = new Color(230, 230, 230);

  /**
   * Background color of selected row and column headers.
   */
  private static Color header_selected_color = new Color(200, 200, 200);

  /**
   * Foreground color of table headers.
   */
  private static Color cell_forecolor = new Color(0, 0, 0);

  /**
   * Background color of selected cells.
   */
  private static Color cell_selected_color = new Color(0, 191, 255);

  /**
   * Background color of unselected cells.
   */
  private static Color cell_unselected_color = new Color(255, 255, 255);

  /**
   * Background color of shaded cells.
   */
  private static Color cell_shaded_color = new Color(191, 239, 255);

  /**
   * Default constructor for creating new TableHandler form.
   */
  public TableHandler() {
    this(new Table(), false);   // FIXME: default is false, to be changed
  }

  /**
   * Constructor for creating new {@link TableHandler} form given
   * underling table and editable status.
   *
   * @param table the underlying {@link Table} storing data.
   * @param isEditable true if editing is allowed, else false.
   */
  public TableHandler(Table table, boolean isEditable) {
    // initialize form components
    initComponents();
    // initialize table object and read-only status
    this.table = table;
    this.isEditable = isEditable;
    // initialize all components
    initSelectionModels();
    initRowTable();
    initMainTable();
    initScrollPane();
    initToolBar();
  }

  /**
   * Returns the row selection model of the {@code TableHandler}.
   *
   * @return the row selection model.
   */
  public ListSelectionModel getRowSelectionModel() {
    return row_selectionModel;
  }

  /**
   * Returns the column selection model of the {@code TableHandler}.
   *
   * @return the column selection model.
   */
  public ListSelectionModel getColSelectionModel() {
    return col_selectionModel;
  }

  /**
   * Returns a list of indexes representing currently selected columns.
   *
   * @return a list of selected column indexes.
   */
  public int[] getSelectedColumns() {
    // store all indexes of selected columns in a list
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = 0; i < table.columns(); i++)
      if (col_selectionModel.isSelectedIndex(i)) list.add(i);
    // convert a list of Integer to an int array
    int[] result = new int[list.size()];
    for (int i = 0; i < list.size(); i++)
      result[i] = list.get(i);
    return result;
  }

  /**
   * Returns a list of indexes representing currently selected rows.
   *
   * @return a list of selected row indexes.
   */
  public int[] getSelectedRows() {
    // store all indexes of selected columns in a list
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = 0; i < table.rows(); i++)
      if (row_selectionModel.isSelectedIndex(i)) list.add(i);
    // convert a list of Integer to an int array
    int[] result = new int[list.size()];
    for (int i = 0; i < list.size(); i++)
      result[i] = list.get(i);
    return result;
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    cols_PopUp = new javax.swing.JPopupMenu();
    col_rename = new javax.swing.JMenuItem();
    col_type = new javax.swing.JMenu();
    col_character = new javax.swing.JRadioButtonMenuItem();
    col_numeric = new javax.swing.JRadioButtonMenuItem();
    col_separator = new javax.swing.JPopupMenu.Separator();
    col_insert = new javax.swing.JMenuItem();
    col_delete = new javax.swing.JMenuItem();
    rows_PopUp = new javax.swing.JPopupMenu();
    scrollPane = new javax.swing.JScrollPane();
    toolBar = new javax.swing.JToolBar();
    tableNameLabel = new javax.swing.JLabel();
    toolBarFiller = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(32767, 0));

    col_rename.setText("Rename");
    col_rename.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        col_renameActionPerformed(evt);
      }
    });
    cols_PopUp.add(col_rename);

    col_type.setText("Column type");

    col_character.setSelected(true);
    col_character.setText("Character");
    col_type.add(col_character);

    col_numeric.setSelected(true);
    col_numeric.setText("Numeric");
    col_type.add(col_numeric);

    cols_PopUp.add(col_type);
    cols_PopUp.add(col_separator);

    col_insert.setText("Insert");
    cols_PopUp.add(col_insert);

    col_delete.setText("Delete");
    cols_PopUp.add(col_delete);

    tableNameLabel.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
    tableNameLabel.setText("Table name");
    toolBar.add(tableNameLabel);
    toolBar.add(toolBarFiller);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(scrollPane)
      .addComponent(toolBar, javax.swing.GroupLayout.DEFAULT_SIZE, 425, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addComponent(toolBar, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 327, Short.MAX_VALUE))
    );
  }// </editor-fold>//GEN-END:initComponents

  /**
   * Handles column renaming on current selection. Because the methods uses
   * currently selected columns from {@code col_selectionModel}, an
   * {@code IllegalArgumentException} will be thrown if selection is null.
   * The method will ask for a column name to be used for single or multiple
   * column renaming. For multiple column renaming a progressive number,
   * starting from one, will be used. Before actual renaming, the method will
   * check if column name(s) are allowed in the table. If one of them is not
   * allowed, the renaming operation will be aborted.
   *
   * @param evt the action event
   * @throws IllegalArgumentException if no column is selected
   */
    private void col_renameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_col_renameActionPerformed
      // get selected columns and check for empty selection
      int[] selected_cols = getSelectedColumns();
      if (selected_cols.length == 0)
        throw new IllegalArgumentException("Empty column selection.");
      // ask for a new column name
      String rootName = JOptionPane.showInputDialog(this,
              "Insert new column name", "Rename column(s)...",
              JOptionPane.QUESTION_MESSAGE);
      // check if rename operation was aborted
      if (rootName == null) return;
      // check if all column names are valid
      String columnName = rootName;
      String error_log = new String();
      boolean error_state = false;
      for (int i = 0; i < selected_cols.length; i++)
      {
        if (selected_cols.length != 1) columnName = rootName + (i + 1);
        // generate an error message if column name is not valid
        if (!table.isColumnNameValid(columnName))
        {
          error_state = true;
          error_log += "ERROR: " + (columnName.isEmpty()
                  ? "Empty name" : "\"" + columnName + "\"\n");
        }
      }
      // show an error message with details of unvalid column names
      if (error_state)
      {
        JOptionPane.showMessageDialog(this,
                "Column name(s) must be unique inside the table and "
                + "cannot be empty.\n\n" + error_log,
                "Invalid column name(s)",
                JOptionPane.ERROR_MESSAGE);
        return;
      }
      // for each selected column change column name
      columnName = rootName;
      for (int i = 0; i < selected_cols.length; i++)
      {
        if (selected_cols.length != 1) columnName = rootName + (i + 1);
        // change column name in the table and update TableColumnModel
        table.setColumnName(selected_cols[i], columnName);
        TableColumn column = main_table.getColumnModel()
                .getColumn(selected_cols[i]);
        column.setHeaderValue(columnName);
      }
      // update main table
      main_table.getTableHeader().repaint();
    }//GEN-LAST:event_col_renameActionPerformed

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JRadioButtonMenuItem col_character;
  private javax.swing.JMenuItem col_delete;
  private javax.swing.JMenuItem col_insert;
  private javax.swing.JRadioButtonMenuItem col_numeric;
  private javax.swing.JMenuItem col_rename;
  private javax.swing.JPopupMenu.Separator col_separator;
  private javax.swing.JMenu col_type;
  private javax.swing.JPopupMenu cols_PopUp;
  private javax.swing.JPopupMenu rows_PopUp;
  private javax.swing.JScrollPane scrollPane;
  private javax.swing.JLabel tableNameLabel;
  private javax.swing.JToolBar toolBar;
  private javax.swing.Box.Filler toolBarFiller;
  // End of variables declaration//GEN-END:variables

  /**
   * Initializes both row and column selection model.
   */
  private void initSelectionModels() {
    // initialize row and column selection models
    row_selectionModel = new DefaultListSelectionModel();
    col_selectionModel = new DefaultListSelectionModel();
    // refresh row and main table upon selection
    row_selectionModel.addListSelectionListener(
            new ListSelectionListener() {
      /**
       * Refreshes main table upon row selection.
       */
      @Override
      public void valueChanged(ListSelectionEvent e) {
        main_table.repaint();
      }
    });
    col_selectionModel.addListSelectionListener(
            new ListSelectionListener() {
      /**
       * Refreshes main table and header upon column selection.
       */
      @Override
      public void valueChanged(ListSelectionEvent e) {
        main_table.getTableHeader().repaint();
        main_table.repaint();
      }
    });
  }

  /**
   * Initializes the row table for number labeling.
   */
  private void initRowTable() {
    // initialize row table with its table model
    row_table = new JTable(new RowTableModel(table)) {
      /**
       * The method is overridden in order to handle multiple toggle
       * row selection.
       */
      @Override
      public void changeSelection(int rowIndex, int columnIndex,
              boolean toggle, boolean extend) {

        // check if shift key is pressed for range selection
        if (extend)
        {
          int lastIndex = row_selectionModel.getLeadSelectionIndex();
          row_selectionModel.addSelectionInterval(lastIndex, rowIndex);
          return;
        }
        // check if control key is pressed for toogle selection
        if (toggle)
        {
          // select or unselect based on current selection
          if (row_selectionModel.isSelectedIndex(rowIndex))
            row_selectionModel.removeSelectionInterval(rowIndex, rowIndex);
          else row_selectionModel.addSelectionInterval(rowIndex, rowIndex);
          return;
        }
        // unselect the clicked row is alrealdy selected        
        if (row_selectionModel.isSelectedIndex(rowIndex))
          row_selectionModel.removeSelectionInterval(rowIndex, rowIndex);
        // else reset row selection and select clicked row
        else
        {
          row_selectionModel.clearSelection();
          row_selectionModel.addSelectionInterval(rowIndex, rowIndex);
        }
      }
    };
    // set row table properties for autoresizing and selection model
    row_table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
    row_table.setSelectionModel(row_selectionModel);
    // set the default renderer for visual appereance
    row_table.setDefaultRenderer(Object.class, new TableCellRenderer() {
      /**
       * When displayed, the content of the table is formatted according
       * to the selection state. The default alignment is right because the
       * table contains row numbers.
       */
      @Override
      public Component getTableCellRendererComponent(
              JTable table, Object value, boolean isSelected,
              boolean hasFocus, int row, int column) {
        // create new label for showing row number
        JLabel cell = new JLabel();
        cell.setOpaque(true);
        cell.setText(value.toString());
        cell.setHorizontalAlignment(JLabel.RIGHT);
        // set foreground color 
        cell.setForeground(header_forecolor);
        // set background color upon selection
        if (isSelected) cell.setBackground(header_selected_color);
        else cell.setBackground(header_unselected_color);
        // returns the newly created label
        return cell;
      }
    });
  }

  /**
   * Initializes the main table for data display and editing.
   */
  private void initMainTable() {
    // initialize main_table with its data model
    main_table = new JTable(new MainTableModel(table, isEditable));
    // set main table properties for autoresizing 
    // and row-column selection model
    main_table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
    main_table.setColumnSelectionAllowed(true);
    main_table.setSelectionModel(row_selectionModel);
    main_table.getColumnModel().setSelectionModel(col_selectionModel);
    // set default cell and table header renderers for visual appearance
    main_table.setDefaultRenderer(Object.class, new TableCellRenderer() {
      /**
       * The content of the table is formatted according to data type and
       * selection state. The cell alignment depends on column data type,
       * default is left for character and right for numeric.
       */
      @Override
      public Component getTableCellRendererComponent(
              JTable table, Object value, boolean isSelected,
              boolean hasFocus, int row, int column) {
        // convert input in Data object
        Data data = (Data) value;
        // create new label for showing cell content
        JLabel cell = new JLabel();
        cell.setOpaque(true);
        // set alignment based on Data type
        switch (data.type())
        {
          case NUMERIC:
            cell.setHorizontalAlignment(JLabel.RIGHT);
            break;
          case CHARACTER:
          case UNDEFINED:
            cell.setHorizontalAlignment(JLabel.LEFT);
        }
        // set cell content based on Data value and type
        if (data.isEmpty() && data.type() == DataType.NUMERIC)
          cell.setText(".");
        else cell.setText(data.toString());
        // set cell foreground and background based on current selection
        cell.setForeground(cell_forecolor);
        if (isSelected) cell.setBackground(cell_selected_color);
        else if (row_selectionModel.isSelectedIndex(row)
                || col_selectionModel.isSelectedIndex(column))
          cell.setBackground(cell_shaded_color);
        else cell.setBackground(cell_unselected_color);
        // return the newly created label
        return cell;
      }
    });
    main_table.getTableHeader().setDefaultRenderer(new TableCellRenderer() {
      /**
       * The content of the table header is rendered based on type and
       * selection. The default alignment for table header is centered.
       */
      @Override
      public Component getTableCellRendererComponent(
              JTable table, Object value, boolean isSelected,
              boolean hasFocus, int row, int column) {
        // create new label to show the content of the header
        JLabel header = new JLabel();
        header.setOpaque(true);
        header.setText(value.toString());    // actual class is String
        header.setHorizontalAlignment(JLabel.CENTER);
        header.setBorder(new MetalBorders.TableHeaderBorder());
        header.setPreferredSize(new Dimension(50, 30));
        // set foreground and background color based on column selection
        header.setForeground(header_forecolor);
        /* because the method returns always false, the column selection 
         * must be checked through column selection model. */
        isSelected = col_selectionModel.isSelectedIndex(column);
        if (isSelected) header.setBackground(header_selected_color);
        else header.setBackground(header_unselected_color);
        // return the newly created label
        return header;
      }
    });
    // set table header behaviour on mouse input
    main_table.getTableHeader().addMouseListener(new MouseListener() {
      /**
       * Handles column selection, column addition to the end of the table and
       * pop-up menu. If user clicks on the table header but not pointing a
       * column a new column is added to the end of the table. Pressing CTRL
       * key allow for multiple column addition. When user click on column
       * headers, it select them. Thanks to key modifiers (CTRL, SHIFT) the
       * selection mode changes to toggle and range selection.
       */
      @Override
      public void mouseClicked(MouseEvent e) {
        // get index of clicked column
        int colIndex = main_table.getTableHeader().columnAtPoint(e.getPoint());
        // manage click on null column
        if (colIndex == -1)
        {
          // on double left-click inset a column at the end of the table
          if (isEditable && e.getButton() == MouseEvent.BUTTON1
                  && e.getClickCount() == 2)
          {
            // get number of columns to be inserted
            int colNumber = 1;
            // check if control is pressed to add more columns at once
            if (e.getModifiersEx() == MouseEvent.CTRL_DOWN_MASK)
            {
              try
              {
                // ask for column number and check if it is positive
                colNumber = Integer.parseInt(JOptionPane.showInputDialog(
                        scrollPane, "Insert number of columns to be added",
                        "Add columns...", JOptionPane.QUESTION_MESSAGE));
                if (colNumber <= 0) throw new NumberFormatException();
              } catch (NumberFormatException ex)
              {
                JOptionPane.showMessageDialog(scrollPane,
                        "You must insert a positive integer number.",
                        "Validation error", JOptionPane.ERROR_MESSAGE);
                return;
              }
            }
            // add columns to the table object, by default of character type
            table.addColumns(colNumber);
            // update table column model of main table
            for (int i = colNumber; i > 0; i--)
            {
              int index = table.columns() - i;
              TableColumn tableColumn = new TableColumn();
              tableColumn.setModelIndex(index);
              tableColumn.setHeaderValue(table.getColumnName(index));
              main_table.addColumn(tableColumn);
            }
          }
          // this return statement prevents improper usage of null index
          return;
        }
        // manage column selection
        if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 1)
        {
          // check if shift button is pressed to select a range
          if (e.getModifiersEx() == MouseEvent.SHIFT_DOWN_MASK)
          {
            int lastIndex = col_selectionModel.getLeadSelectionIndex();
            col_selectionModel.addSelectionInterval(lastIndex, colIndex);
            return;

          }
          // check if control button is pressed to toggle select
          if (e.getModifiersEx() == MouseEvent.CTRL_DOWN_MASK)
          {
            // select or unselect based on current selection
            if (col_selectionModel.isSelectedIndex(colIndex))
              col_selectionModel.removeSelectionInterval(colIndex, colIndex);
            else col_selectionModel.addSelectionInterval(colIndex, colIndex);
            return;
          }
          // unselect the clicked column is alrealdy selected
          if (col_selectionModel.isSelectedIndex(colIndex))
            col_selectionModel.removeSelectionInterval(colIndex, colIndex);
          // else reset column selection and select clicked column
          else
          {
            col_selectionModel.clearSelection();
            col_selectionModel.addSelectionInterval(colIndex, colIndex);
          }
        }
        // manage popup call
        if (e.getButton() == MouseEvent.BUTTON3 && e.getClickCount() == 1)
        {
          // if clicked column is not selected set it as unique selection
          if (!col_selectionModel.isSelectedIndex(colIndex))
          {
            col_selectionModel.clearSelection();
            col_selectionModel.addSelectionInterval(colIndex, colIndex);
          }
          // set menu item enable state
          col_character.setEnabled(isEditable);
          col_numeric.setEnabled(isEditable);
          col_rename.setEnabled(isEditable);
          col_insert.setEnabled(isEditable);
          col_delete.setEnabled(isEditable);
          // set column type menu on current selection
          int[] selected_cols = getSelectedColumns();
          if (selected_cols.length == 1)
          {
            // if single column is selected show its type
            col_character.setSelected(table.getColumnType(selected_cols[0])
                    == DataType.CHARACTER);
            col_numeric.setSelected(table.getColumnType(selected_cols[0])
                    == DataType.NUMERIC);
          } else
          {
            // for multiple selection let both unselected
            col_character.setSelected(false);
            col_numeric.setSelected(false);
          }
          // show the column popup
          cols_PopUp.show(main_table.getTableHeader(), e.getX(), e.getY());
        }

      }

      /**
       * Method not implemented.
       */
      @Override
      public void mousePressed(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseReleased(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseEntered(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseExited(MouseEvent e) {
      }
    });
  }

  /**
   * Initializes the scroll pane.
   */
  private void initScrollPane() {
    // initialize viewport to layout row table
    JViewport row_view = new JViewport() {
      /**
       * Override getPreferredSize in order to allow proper scrolling.
       */
      @Override
      public Dimension getPreferredSize() {
        return row_table.getPreferredSize();
      }
    };
    row_view.setView(row_table);
    // set scrollpane components
    scrollPane.setRowHeaderView(row_view);
    scrollPane.setViewportView(main_table);
    // set the row header behaviour upon mouse input
    scrollPane.getRowHeader().addMouseListener(new MouseListener() {
      /**
       * Handles row addition at the end of the table. By double left-click on
       * row header a new row is added at the end of the table. Pressing CTRL
       * key allow for multiple row addition.
       */
      @Override
      public void mouseClicked(MouseEvent e) {
        // manage row addition at the end of the table
        if (isEditable && e.getButton() == MouseEvent.BUTTON1
                && e.getClickCount() == 2)
        {
          // get number of rows to be inserted
          int rowNumber = 1;
          // check if control is pressed to add more rows at once
          if (e.getModifiersEx() == MouseEvent.CTRL_DOWN_MASK)
          {
            try
            {
              // ask for row number and check it is positive
              rowNumber = Integer.parseInt(JOptionPane.showInputDialog(
                      scrollPane, "Insert number of rows to be added",
                      "Add rows...", JOptionPane.QUESTION_MESSAGE));
              if (rowNumber <= 0) throw new NumberFormatException();
            } catch (NumberFormatException ex)
            {
              JOptionPane.showMessageDialog(scrollPane,
                      "You must insert a positive integer number.",
                      "Validation error", JOptionPane.ERROR_MESSAGE);
              return;
            }
          }
          // add row to Table object
          table.addRows(rowNumber);
          // update row and main table models
          int lastRow = table.rows() - rowNumber;
          RowTableModel row_model = (RowTableModel) row_table.getModel();
          MainTableModel main_model = (MainTableModel) main_table.getModel();
          row_model.fireTableRowsInserted(lastRow, table.rows() - 1);
          main_model.fireTableRowsInserted(lastRow, table.rows() - 1);
        }

      }

      /**
       * Method not implemented.
       */
      @Override
      public void mousePressed(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseReleased(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseEntered(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseExited(MouseEvent e) {
      }
    });
  }

  /**
   * Initializes the tool bar.
   */
  private void initToolBar() {
    // initialize table name label
    tableNameLabel.setText(table.name());    
    // FIXME:for debug purpose, to be removed
    tableNameLabel.addMouseListener(new MouseListener() {
      @Override
      public void mouseClicked(MouseEvent e) {
        System.out.println(table);
      }

      @Override
      public void mousePressed(MouseEvent e) {
      }

      @Override
      public void mouseReleased(MouseEvent e) {
      }

      @Override
      public void mouseEntered(MouseEvent e) {
      }

      @Override
      public void mouseExited(MouseEvent e) {
      }
    });
  }

}
