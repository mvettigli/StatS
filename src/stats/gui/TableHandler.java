/* ----------------------------------------------------------------------------
 * File: TableHandler.java
 * Date: May 16th, 2013
 * ----------------------------------------------------------------------------
 */
package stats.gui;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalBorders;
import javax.swing.table.*;
import stats.core.*;
import static stats.core.DataType.*;
import stats.gui.dialogs.*;

/**
 *
 * @author marco
 */
public class TableHandler extends javax.swing.JPanel {

  /**
   * Table object holding data.
   */
  private stats.core.Table table;

  /**
   * Read-only status of the TableHandler object.
   */
  private boolean isEditable;

  /**
   * The JTable object showing data contained in table object.
   */
  private javax.swing.JTable main_table;

  /**
   * The JTable object showing row numbers.
   */
  private javax.swing.JTable row_table;

  /**
   * Row selection status.
   */
  private ListSelectionModel row_selectionModel;

  /**
   * Column selection status.
   */
  private ListSelectionModel col_selectionModel;

  /**
   * Foreground color of table headers.
   */
  private static Color header_forecolor = new Color(0, 0, 0);

  /**
   * Background color of unselected row and column headers.
   */
  private static Color header_unselected_color = new Color(230, 230, 230);

  /**
   * Background color of selected row and column headers.
   */
  private static Color header_selected_color = new Color(200, 200, 200);

  /**
   * Foreground color of table headers.
   */
  private static Color cell_forecolor = new Color(0, 0, 0);

  /**
   * Background color of selected cells.
   */
  private static Color cell_selected_color = new Color(0, 191, 255);

  /**
   * Background color of unselected cells.
   */
  private static Color cell_unselected_color = new Color(255, 255, 255);

  /**
   * Background color of shaded cells.
   */
  private static Color cell_shaded_color = new Color(191, 239, 255);

  /**
   * Storage variable for width of lateral pane.
   */
  private int lateralPaneWidth;

  /**
   * Default constructor for creating new TableHandler form.
   */
  public TableHandler() {
    this(new Table(), false);
  }

  /**
   * Constructor for creating new {@link TableHandler} form given
   * underling table and editable status.
   *
   * @param table the underlying {@link Table} storing data.
   * @param isEditable true if editing is allowed, else false.
   */
  public TableHandler(Table table, boolean isEditable) {
    // initialize form components
    initComponents();
    // initialize table object and read-only status
    this.table = table;
    this.isEditable = isEditable;
    // initialize all components
    initSelectionModels();
    initRowTable();
    initMainTable();
    initScrollPane();
    initToolBar();
    initLateralPane();
  }

  /**
   * Returns the row selection model of the {@code TableHandler}.
   *
   * @return the row selection model.
   */
  public ListSelectionModel getRowSelectionModel() {
    return row_selectionModel;
  }

  /**
   * Returns the column selection model of the {@code TableHandler}.
   *
   * @return the column selection model.
   */
  public ListSelectionModel getColSelectionModel() {
    return col_selectionModel;
  }

  /**
   * Returns a list of indexes representing currently selected columns.
   *
   * @return a list of selected column indexes.
   */
  public int[] getSelectedColumns() {
    // store all indexes of selected columns in a list
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = 0; i < table.columns(); i++)
      if (col_selectionModel.isSelectedIndex(i)) list.add(i);
    // convert a list of Integer to an int array
    int[] result = new int[list.size()];
    for (int i = 0; i < list.size(); i++)
      result[i] = list.get(i);
    return result;
  }

  /**
   * Returns a list of indexes representing currently selected rows.
   *
   * @return a list of selected row indexes.
   */
  public int[] getSelectedRows() {
    // store all indexes of selected columns in a list
    ArrayList<Integer> list = new ArrayList<>();
    for (int i = 0; i < table.rows(); i++)
      if (row_selectionModel.isSelectedIndex(i)) list.add(i);
    // convert a list of Integer to an int array
    int[] result = new int[list.size()];
    for (int i = 0; i < list.size(); i++)
      result[i] = list.get(i);
    return result;
  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    cols_PopUp = new javax.swing.JPopupMenu();
    col_rename = new javax.swing.JMenuItem();
    col_insert = new javax.swing.JMenuItem();
    col_delete = new javax.swing.JMenuItem();
    col_separator = new javax.swing.JPopupMenu.Separator();
    col_type = new javax.swing.JMenu();
    col_character = new javax.swing.JRadioButtonMenuItem();
    col_numeric = new javax.swing.JRadioButtonMenuItem();
    rows_PopUp = new javax.swing.JPopupMenu();
    row_insert = new javax.swing.JMenuItem();
    row_delete = new javax.swing.JMenuItem();
    row_separator = new javax.swing.JPopupMenu.Separator();
    row_color = new javax.swing.JMenu();
    row_marker = new javax.swing.JMenu();
    row_size = new javax.swing.JMenu();
    toolBar = new javax.swing.JToolBar();
    buttonSidePane = new javax.swing.JButton();
    jSeparator1 = new javax.swing.JToolBar.Separator();
    splitMain = new javax.swing.JSplitPane();
    scrollPane = new javax.swing.JScrollPane();
    splitLateral = new javax.swing.JSplitPane();
    scrollColumns = new javax.swing.JScrollPane();
    listColumns = new javax.swing.JList();
    scrollRows = new javax.swing.JScrollPane();
    listRows = new javax.swing.JList();

    col_rename.setText("Rename");
    col_rename.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        col_renameActionPerformed(evt);
      }
    });
    cols_PopUp.add(col_rename);

    col_insert.setText("Insert");
    col_insert.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        col_insertActionPerformed(evt);
      }
    });
    cols_PopUp.add(col_insert);

    col_delete.setText("Delete");
    col_delete.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        col_deleteActionPerformed(evt);
      }
    });
    cols_PopUp.add(col_delete);
    cols_PopUp.add(col_separator);

    col_type.setText("Column type");

    col_character.setSelected(true);
    col_character.setText("Character");
    col_type.add(col_character);

    col_numeric.setSelected(true);
    col_numeric.setText("Numeric");
    col_type.add(col_numeric);

    cols_PopUp.add(col_type);

    row_insert.setText("Insert");
    row_insert.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        row_insertActionPerformed(evt);
      }
    });
    rows_PopUp.add(row_insert);

    row_delete.setText("Delete");
    row_delete.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        row_deleteActionPerformed(evt);
      }
    });
    rows_PopUp.add(row_delete);
    rows_PopUp.add(row_separator);

    row_color.setText("Color");
    rows_PopUp.add(row_color);

    row_marker.setText("Marker");
    rows_PopUp.add(row_marker);

    row_size.setText("Size");
    rows_PopUp.add(row_size);

    toolBar.setFloatable(false);

    buttonSidePane.setIcon(new javax.swing.ImageIcon(getClass().getResource("/stats/gui/images/application_side_boxes.png"))); // NOI18N
    buttonSidePane.setToolTipText("Show/hide lateral pane");
    buttonSidePane.setFocusable(false);
    buttonSidePane.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    buttonSidePane.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    buttonSidePane.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        buttonSidePaneActionPerformed(evt);
      }
    });
    toolBar.add(buttonSidePane);
    toolBar.add(jSeparator1);

    splitMain.setBorder(null);
    splitMain.setDividerLocation(150);
    splitMain.setDividerSize(2);

    scrollPane.setBorder(null);
    splitMain.setRightComponent(scrollPane);

    splitLateral.setBorder(null);
    splitLateral.setDividerSize(2);
    splitLateral.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
    splitLateral.setResizeWeight(0.5);
    splitLateral.setMinimumSize(new java.awt.Dimension(0, 0));

    scrollColumns.setBorder(javax.swing.BorderFactory.createTitledBorder("Columns"));
    scrollColumns.setViewportView(listColumns);

    splitLateral.setTopComponent(scrollColumns);

    scrollRows.setBorder(javax.swing.BorderFactory.createTitledBorder("Rows"));
    scrollRows.setViewportView(listRows);

    splitLateral.setRightComponent(scrollRows);

    splitMain.setLeftComponent(splitLateral);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(toolBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
      .addComponent(splitMain, javax.swing.GroupLayout.DEFAULT_SIZE, 385, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addComponent(toolBar, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(splitMain, javax.swing.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE))
    );
  }// </editor-fold>//GEN-END:initComponents

  /**
   * Handles column renaming on current selection. Because the methods uses
   * currently selected columns from {@code col_selectionModel}, an
   * {@code IllegalArgumentException} will be thrown if selection is null.
   * The method will ask for a column name to be used for single or multiple
   * column renaming. For multiple column renaming a progressive number,
   * starting from one, will be used. Before actual renaming, the method will
   * check if column name(s) are allowed in the table. If one of them is not
   * allowed, the renaming operation will be aborted.
   *
   * @param evt the action event.
   * @throws IllegalArgumentException if no column is selected.
   */
  private void col_renameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_col_renameActionPerformed
    // get selected columns and check for empty selection
    int[] selected_cols = getSelectedColumns();
    if (selected_cols.length == 0)
      throw new IllegalArgumentException("Empty column selection.");
    // ask for a new column name
    String rootName = JOptionPane.showInputDialog(this,
            "Insert new column name", "Rename column(s)...",
            JOptionPane.QUESTION_MESSAGE);
    // check if rename operation was aborted
    if (rootName == null) return;
    // check if all column names are valid
    String columnName = rootName;
    String error_log = new String();
    boolean error_state = false;
    for (int i = 0; i < selected_cols.length; i++)
    {
      if (selected_cols.length != 1) columnName = rootName + (i + 1);
      // generate an error message if column name is not valid
      if (!table.isColumnNameValid(columnName))
      {
        error_state = true;
        error_log += "ERROR: " + (columnName.isEmpty()
                ? "Empty name" : "\"" + columnName + "\"\n");
      }
    }
    // show an error message with details of unvalid column names
    if (error_state)
    {
      JOptionPane.showMessageDialog(this,
              "Column name(s) must be unique inside the table and "
              + "cannot be empty.\n\n" + error_log,
              "Invalid column name(s)",
              JOptionPane.ERROR_MESSAGE);
      return;
    }
    // for each selected column change column name
    columnName = rootName;
    for (int i = 0; i < selected_cols.length; i++)
    {
      if (selected_cols.length != 1) columnName = rootName + (i + 1);
      // change column name in the table and update TableColumnModel
      table.setColumnName(selected_cols[i], columnName);
      TableColumn column = main_table.getColumnModel()
              .getColumn(selected_cols[i]);
      column.setHeaderValue(columnName);
    }
    // update main table and column list
    main_table.getTableHeader().updateUI();
    listColumns.updateUI();
  }//GEN-LAST:event_col_renameActionPerformed

  /**
   * Handles column insertion upon selection. Because the methods uses
   * currently selected columns from {@code col_selectionModel}, an {@code
   * IllegalArgumentException} will be thrown if selection is null. The
   * insertion is performed based on column type, number and insertion position.
   * When multiple selection or number of columns is present, the name of the
   * columns is built using the root name given by the user, followed by
   * (one or two) indexes. If the names of the column to be inserted is not
   * valid, the operation is aborted.
   *
   * @param evt the action event.
   * @throws IllegalArgumentException if no column is selected.
   */
  private void col_insertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_col_insertActionPerformed
    // get selected columns and check for empty selection
    int[] selected_cols = getSelectedColumns();
    if (selected_cols.length == 0) throw new IllegalArgumentException(
              "Empty column selection.");
    // create a dialog for column insertion
    JFrame mainFrame = (JFrame) SwingUtilities.getRoot(this);
    DialogInsertCols dialog = new DialogInsertCols(mainFrame, true);
    dialog.setLocationRelativeTo(mainFrame);
    // show the dialog and exit if operation is aborted
    if (!dialog.showDialog()) return;
    // define variable for convenience
    TableColumnModel model = main_table.getColumnModel();
    String rootName = dialog.getColumnName();
    int number = dialog.getColumnNumber();
    DataType type = dialog.getColumnType();
    // check if the names of the new columns are valid
    boolean error_state = true;
    String error_log = new String();
    // for each column name to be inserted,
    // check its validity in the table object
    for (int i = 0; i < selected_cols.length; i++)
      for (int j = 0; j < number; j++)
      {
        String columnName = rootName
                + ((selected_cols.length != 1) ? (i + 1) : "")
                + ((number != 1) ? (j + 1) : "");
        if (!table.isColumnNameValid(columnName))
        {
          error_log += "ERROR: " + (columnName.isEmpty()
                  ? "Empty name" : "\"" + columnName + "\"\n");
          error_state = false;
        }
      }
    // show an error message with a log 
    // reporting all invalid column names
    if (!error_state)
    {
      JOptionPane.showMessageDialog(this,
              "Column name(s) must be unique inside the table and "
              + "cannot be empty.\n\n" + error_log,
              "Invalid column name(s)",
              JOptionPane.ERROR_MESSAGE);
      return;
    }
    // based on insertion position modify the selection  
    int[] newSelection = new int[1];
    col_selectionModel.clearSelection();
    switch (dialog.getColumnPosition())
    {
      case DialogInsertCols.POSITION_BEGIN:
        newSelection[0] = 0;
        selected_cols = newSelection;
        break;
      case DialogInsertCols.POSITION_END:
        newSelection[0] = model.getColumnCount();
        selected_cols = newSelection;
        break;
      case DialogInsertCols.POSITION_AFTER:
        for (int i = 0; i < selected_cols.length; i++)
          selected_cols[i] += 1;
      case DialogInsertCols.POSITION_BEFORE:
      default:
    }
    // insert the columns 
    for (int i = 0; i < selected_cols.length; i++)
    {
      int index = selected_cols[i];
      // insert and rename columns in the Table object
      if (index == table.columns()) table.addColumns(type, number);
      else table.insertColumns(index, type, number);
      for (int j = 0; j < number; j++)
        table.setColumnName(index + j, rootName
                + ((selected_cols.length != 1) ? (i + 1) : "")
                + ((number != 1) ? (j + 1) : ""));
      // shift all next columns forward by n positions
      for (int j = 0; j < model.getColumnCount(); j++)
      {
        int currIndex = model.getColumn(j).getModelIndex();
        if (currIndex >= index)
          model.getColumn(j).setModelIndex(currIndex + number);
      }
      // add columns to JTable object
      for (int j = 0; j < number; j++)
      {
        TableColumn tableColumn = new TableColumn();
        tableColumn.setModelIndex(index + j);
        tableColumn.setHeaderValue(table.getColumnName(index + j));
        model.addColumn(tableColumn);
        // the model adds columns at the end of the table with defined
        // model index, they must be moved to the correct position
        model.moveColumn(model.getColumnCount() - 1, index + j);
      }
      // select newly created columns
      col_selectionModel.addSelectionInterval(
              selected_cols[i],
              selected_cols[i] + number - 1);
      // update next selected index to shift the selection
      if (i != selected_cols.length - 1)
        selected_cols[i + 1] += number * (i + 1);
    }
    // update main table and column list    
    listColumns.updateUI();
  }//GEN-LAST:event_col_insertActionPerformed

  /**
   * Handles column removal upon selection. Because the methods uses
   * currently selected columns from {@code col_selectionModel}, an {@code
   * IllegalArgumentException} will be thrown if selection is null. At least
   * one column must be present in the table. This method will parse current
   * column selection and remove both data and {@link TableColumn} objects.
   * Other column indexes must be shift to match table model.
   *
   * @param evt the action event.
   * @throws IllegalArgumentException if no column is selected.
   */
  private void col_deleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_col_deleteActionPerformed
    // get selected columns and check for empty selection
    int[] selected_cols = getSelectedColumns();
    if (selected_cols.length == 0)
      throw new IllegalArgumentException("Empty column selection.");
    // check for maximum number of columns to be deleted
    if (selected_cols.length == table.columns())
    {
      JOptionPane.showMessageDialog(this,
              "Cannot delete all column in the table",
              "Delete error", JOptionPane.ERROR_MESSAGE);
      return;
    }
    // parse the selected indexes for column removal
    TableColumnModel model = main_table.getColumnModel();
    for (int i = selected_cols.length - 1; i >= 0; i--)
    {
      // remove selected column
      int index = selected_cols[i];
      model.removeColumn(model.getColumn(index));
      // shift back next columns by one position
      for (int j = index; j < model.getColumnCount(); j++)
      {
        int currIndex = model.getColumn(j).getModelIndex();
        model.getColumn(j).setModelIndex(currIndex - 1);
      }
      // remove selection and actual column from table
      col_selectionModel.removeIndexInterval(index, index);
      table.removeColumn(index);
    }
    // update column list
    listColumns.updateUI();
  }//GEN-LAST:event_col_deleteActionPerformed

  /**
   * Handles row insertion upon selection. Because the methods uses currently
   * selected rows from {@code row_selectionModel}, an {@code
   * IllegalArgumentException} will be thrown if selection is null. The
   * insertion is performed based on number and insertion position.
   *
   * @param evt the action event.
   * @throws IllegalArgumentException if no row is selected.
   */
  private void row_insertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_row_insertActionPerformed
    // check if row selection is null
    int[] selected_rows = getSelectedRows();
    if (selected_rows.length == 0) throw new IllegalArgumentException(
              "Empty row selection");
    //
    JFrame mainFrame = (JFrame) SwingUtilities.getRoot(this);
    DialogInsertRows dialog = new DialogInsertRows(mainFrame, true);
    dialog.setLocationRelativeTo(mainFrame);
    // show the dialog and exit if operation is aborted
    if (!dialog.showDialog()) return;
    // define variables for convenience
    int number = dialog.getRowNumber();
    int position = dialog.getRowPosition();
    int[] new_selection = new int[1];
    // based on insertion position, modify selected indexes
    switch (position)
    {
      case DialogInsertRows.POSITION_BEGIN:
        new_selection[0] = 0;
        selected_rows = new_selection;
        break;
      case DialogInsertRows.POSITION_END:
        new_selection[0] = table.rows();
        selected_rows = new_selection;
        break;
      case DialogInsertRows.POSITION_AFTER:
        for (int i = 0; i < selected_rows.length; i++)
          selected_rows[i] += 1;
      case DialogInsertRows.POSITION_BEFORE:
      default:
    }
    // clear row selection and insert new rows
    row_selectionModel.clearSelection();
    for (int i = 0; i < selected_rows.length; i++)
    {
      // insert rows in the Table object
      if (selected_rows[i] != table.rows())
        table.insertRows(selected_rows[i], number);
      else table.addRows(number);
      // select newly created rows
      row_selectionModel.addSelectionInterval(
              selected_rows[i],
              selected_rows[i] + number - 1);
      // update next selected index to shift the selection
      if (i != selected_rows.length - 1)
        selected_rows[i + 1] += number * (i + 1);
    }
    // repaint components
    row_table.updateUI();
    main_table.updateUI();
  }//GEN-LAST:event_row_insertActionPerformed

  /**
   * Handles row removal upon selection. Because the methods uses currently
   * selected rows from {@code row_selectionModel}, an {@code
   * IllegalArgumentException} will be thrown if selection is null. At least
   * one row must be present in the table, if user attempts to remove all rows,
   * the operation will be aborted. At the end of the operation the row
   * selection will be cleared.
   *
   * @param evt the action event.
   * @throws IllegalArgumentException if no row is selected.
   */
  private void row_deleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_row_deleteActionPerformed
    // check if row selection is null
    int[] selected_rows = getSelectedRows();
    if (selected_rows.length == 0) throw new IllegalArgumentException(
              "Empty row selection");
    // check if at least one row remains in the table
    if (selected_rows.length == table.rows())
    {
      JOptionPane.showMessageDialog(this,
              "Cannot delete all rows in the table",
              "Delete error", JOptionPane.ERROR_MESSAGE);
      return;
    }
    // remove rows from the Table object
    for (int i = 0; i < selected_rows.length; i++)
    {
      table.removeRow(selected_rows[i]);
      // shift backward the next selection
      if (i != selected_rows.length - 1)
        selected_rows[i + 1] -= i + 1;
    }
    // clear row selection and repaint components
    row_selectionModel.clearSelection();
    row_table.updateUI();
    main_table.updateUI();
  }//GEN-LAST:event_row_deleteActionPerformed

  /**
   * Handles lateral panel visibility. The lateral panel is shown or hidden
   * based on its current state. When user hides the pane, its width is store
   * in the local variable {@code lateralPaneWidth}. This variable is used to
   * restore panel width when user set it visible.
   *
   * @param evt the action event.
   */
  private void buttonSidePaneActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonSidePaneActionPerformed
    // check if the side panel is already hidden and hide/show it
    if (splitMain.getDividerLocation() != 0)
    {
      // store the current width in the local variable
      lateralPaneWidth = splitMain.getDividerLocation();
      splitMain.setDividerLocation(0);
      // restore the width of the lateral panel
    } else splitMain.setDividerLocation(lateralPaneWidth);
  }//GEN-LAST:event_buttonSidePaneActionPerformed

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton buttonSidePane;
  private javax.swing.JRadioButtonMenuItem col_character;
  private javax.swing.JMenuItem col_delete;
  private javax.swing.JMenuItem col_insert;
  private javax.swing.JRadioButtonMenuItem col_numeric;
  private javax.swing.JMenuItem col_rename;
  private javax.swing.JPopupMenu.Separator col_separator;
  private javax.swing.JMenu col_type;
  private javax.swing.JPopupMenu cols_PopUp;
  private javax.swing.JToolBar.Separator jSeparator1;
  private javax.swing.JList listColumns;
  private javax.swing.JList listRows;
  private javax.swing.JMenu row_color;
  private javax.swing.JMenuItem row_delete;
  private javax.swing.JMenuItem row_insert;
  private javax.swing.JMenu row_marker;
  private javax.swing.JPopupMenu.Separator row_separator;
  private javax.swing.JMenu row_size;
  private javax.swing.JPopupMenu rows_PopUp;
  private javax.swing.JScrollPane scrollColumns;
  private javax.swing.JScrollPane scrollPane;
  private javax.swing.JScrollPane scrollRows;
  private javax.swing.JSplitPane splitLateral;
  private javax.swing.JSplitPane splitMain;
  private javax.swing.JToolBar toolBar;
  // End of variables declaration//GEN-END:variables

  /**
   * Initializes both row and column selection model.
   */
  private void initSelectionModels() {
    // initialize row and column selection models
    row_selectionModel = new DefaultListSelectionModel();
    col_selectionModel = new DefaultListSelectionModel();
    // refresh row and main table upon selection
    row_selectionModel.addListSelectionListener(
            new ListSelectionListener() {
      /**
       * Refreshes main table upon row selection.
       */
      @Override
      public void valueChanged(ListSelectionEvent e) {
        main_table.repaint();
      }
    });
    col_selectionModel.addListSelectionListener(
            new ListSelectionListener() {
      /**
       * Refreshes main table and header upon column selection.
       */
      @Override
      public void valueChanged(ListSelectionEvent e) {
        main_table.getTableHeader().repaint();
        main_table.repaint();
      }
    });
  }

  /**
   * Initializes the row table for number labeling.
   */
  private void initRowTable() {
    // initialize row table with its table model
    row_table = new JTable(new RowTableModel(table)) {
      /**
       * The method is overridden in order to handle multiple toggle
       * row selection.
       */
      @Override
      public void changeSelection(int rowIndex, int columnIndex,
              boolean toggle, boolean extend) {

        // check if shift key is pressed for range selection
        if (extend)
        {
          int lastIndex = row_selectionModel.getLeadSelectionIndex();
          row_selectionModel.addSelectionInterval(lastIndex, rowIndex);
          return;
        }
        // check if control key is pressed for toogle selection
        if (toggle)
        {
          // select or unselect based on current selection
          if (row_selectionModel.isSelectedIndex(rowIndex))
            row_selectionModel.removeSelectionInterval(rowIndex, rowIndex);
          else row_selectionModel.addSelectionInterval(rowIndex, rowIndex);
          return;
        }
        // unselect the clicked row is alrealdy selected        
        if (row_selectionModel.isSelectedIndex(rowIndex))
          row_selectionModel.removeSelectionInterval(rowIndex, rowIndex);
        // else reset row selection and select clicked row
        else
        {
          row_selectionModel.clearSelection();
          row_selectionModel.addSelectionInterval(rowIndex, rowIndex);
        }
      }
    };
    // set row table properties for autoresizing and selection model
    row_table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);    
    row_table.setSelectionModel(row_selectionModel);
    // set the default renderer for visual appereance
    row_table.setDefaultRenderer(Object.class, new TableCellRenderer() {
      /**
       * When displayed, the content of the table is formatted according
       * to the selection state. The default alignment is right because the
       * table contains row numbers.
       */
      @Override
      public Component getTableCellRendererComponent(
              JTable table, Object value, boolean isSelected,
              boolean hasFocus, int row, int column) {
        // create new label for showing row number
        JLabel cell = new JLabel();
        cell.setOpaque(true);
        cell.setText(value.toString());
        cell.setHorizontalAlignment(JLabel.RIGHT);
        // set foreground color 
        cell.setForeground(header_forecolor);
        // set background color upon selection
        if (isSelected) cell.setBackground(header_selected_color);
        else cell.setBackground(header_unselected_color);
        // returns the newly created label
        return cell;
      }
    });
    row_table.addMouseListener(new MouseListener() {
      @Override
      public void mouseClicked(MouseEvent e) {
        // manage popup call
        if (e.getButton() == MouseEvent.BUTTON3 && e.getClickCount() == 1)
        {
          // get the index of clicked row
          int rowIndex = row_table.rowAtPoint(e.getPoint());
          // manage click on null row
          if (rowIndex == -1) return;
          // manage popup call
          if (e.getButton() == MouseEvent.BUTTON3 && e.getClickCount() == 1)
          {
            // if clicked row is not selected set it as unique selection
            if (!row_selectionModel.isSelectedIndex(rowIndex))
            {
              row_selectionModel.clearSelection();
              row_selectionModel.addSelectionInterval(rowIndex, rowIndex);
            }
            // set menu item enable state
            row_insert.setEnabled(isEditable);
            row_delete.setEnabled(isEditable);
            row_color.setEnabled(true);
            row_marker.setEnabled(true);
            row_size.setEnabled(true);
            // show the row popup
            rows_PopUp.show(row_table, e.getX(), e.getY());
          }
        }
      }

      @Override
      public void mousePressed(MouseEvent e) {
      }

      @Override
      public void mouseReleased(MouseEvent e) {
      }

      @Override
      public void mouseEntered(MouseEvent e) {
      }

      @Override
      public void mouseExited(MouseEvent e) {
      }
    });
  }

  /**
   * Initializes the main table for data display and editing.
   */
  private void initMainTable() {
    // initialize main_table with its data model
    main_table = new JTable(new MainTableModel(table, isEditable));
    // set main table properties for autoresizing 
    // and row-column selection model
    main_table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);    
    main_table.setColumnSelectionAllowed(true);
    main_table.setSelectionModel(row_selectionModel);
    main_table.getColumnModel().setSelectionModel(col_selectionModel);
    // set default cell and table header renderers for visual appearance
    main_table.setDefaultRenderer(Object.class, new TableCellRenderer() {
      /**
       * The content of the table is formatted according to data type and
       * selection state. The cell alignment depends on column data type,
       * default is left for character and right for numeric.
       */
      @Override
      public Component getTableCellRendererComponent(
              JTable table, Object value, boolean isSelected,
              boolean hasFocus, int row, int column) {
        // convert input in Data object
        Data data = (Data) value;
        // create new label for showing cell content
        JLabel cell = new JLabel();
        cell.setOpaque(true);
        // set alignment based on Data type
        switch (data.type())
        {
          case NUMERIC:
            cell.setHorizontalAlignment(JLabel.RIGHT);
            break;
          case CHARACTER:
          case UNDEFINED:
            cell.setHorizontalAlignment(JLabel.LEFT);
        }
        // set cell content based on Data value and type
        if (data.isEmpty() && data.type() == DataType.NUMERIC)
          cell.setText(".");
        else cell.setText(data.toString());
        // set cell foreground and background based on current selection
        cell.setForeground(cell_forecolor);
        if (isSelected) cell.setBackground(cell_selected_color);
        else if (row_selectionModel.isSelectedIndex(row)
                || col_selectionModel.isSelectedIndex(column))
          cell.setBackground(cell_shaded_color);
        else cell.setBackground(cell_unselected_color);
        // return the newly created label
        return cell;
      }
    });
    main_table.getTableHeader().setDefaultRenderer(new TableCellRenderer() {
      /**
       * The content of the table header is rendered based on type and
       * selection. The default alignment for table header is centered.
       */
      @Override
      public Component getTableCellRendererComponent(
              JTable table, Object value, boolean isSelected,
              boolean hasFocus, int row, int column) {
        // create new label to show the content of the header
        JLabel header = new JLabel();
        header.setOpaque(true);
        header.setText(value.toString());    // actual class is String
        header.setHorizontalAlignment(JLabel.CENTER);
        header.setBorder(new MetalBorders.TableHeaderBorder());
        header.setPreferredSize(new Dimension(50, 30));
        // set foreground and background color based on column selection
        header.setForeground(header_forecolor);
        /* because the method returns always false, the column selection 
         * must be checked through column selection model. */
        isSelected = col_selectionModel.isSelectedIndex(column);
        if (isSelected) header.setBackground(header_selected_color);
        else header.setBackground(header_unselected_color);
        // return the newly created label
        return header;
      }
    });
    // set table header behaviour on mouse input
    main_table.getTableHeader().addMouseListener(new MouseListener() {
      /**
       * Handles column selection, column addition to the end of the table and
       * pop-up menu. If user clicks on the table header but not pointing a
       * column a new column is added to the end of the table. Pressing CTRL
       * key allow for multiple column addition. When user click on column
       * headers, it select them. Thanks to key modifiers (CTRL, SHIFT) the
       * selection mode changes to toggle and range selection.
       */
      @Override
      public void mouseClicked(MouseEvent e) {
        // get index of clicked column
        int colIndex = main_table.getTableHeader().columnAtPoint(e.getPoint());
        // manage click on null column
        if (colIndex == -1)
        {
          // on double left-click inset a column at the end of the table
          if (isEditable && e.getButton() == MouseEvent.BUTTON1
                  && e.getClickCount() == 2)
          {
            // get number of columns to be inserted
            int colNumber = 1;
            // check if control is pressed to add more columns at once
            if (e.getModifiersEx() == MouseEvent.CTRL_DOWN_MASK)
            {
              try
              {
                // ask for column number and check if it is positive
                colNumber = Integer.parseInt(JOptionPane.showInputDialog(
                        scrollPane, "Insert number of columns to be added",
                        "Add columns...", JOptionPane.QUESTION_MESSAGE));
                if (colNumber <= 0) throw new NumberFormatException();
              } catch (NumberFormatException ex)
              {
                JOptionPane.showMessageDialog(scrollPane,
                        "You must insert a positive integer number.",
                        "Validation error", JOptionPane.ERROR_MESSAGE);
                return;
              }
            }
            // add columns to the table object, by default of character type
            table.addColumns(colNumber);
            // update table column model of main table
            for (int i = colNumber; i > 0; i--)
            {
              int index = table.columns() - i;
              TableColumn tableColumn = new TableColumn();
              tableColumn.setModelIndex(index);
              tableColumn.setHeaderValue(table.getColumnName(index));
              main_table.addColumn(tableColumn);
            }
            // update column list
            listColumns.updateUI();
          }
          // this return statement prevents improper usage of null index
          return;
        }
        // manage column selection
        if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 1)
        {
          // check if shift button is pressed to select a range
          if (e.getModifiersEx() == MouseEvent.SHIFT_DOWN_MASK)
          {
            int lastIndex = col_selectionModel.getLeadSelectionIndex();
            col_selectionModel.addSelectionInterval(lastIndex, colIndex);
            return;

          }
          // check if control button is pressed to toggle select
          if (e.getModifiersEx() == MouseEvent.CTRL_DOWN_MASK)
          {
            // select or unselect based on current selection
            if (col_selectionModel.isSelectedIndex(colIndex))
              col_selectionModel.removeSelectionInterval(colIndex, colIndex);
            else col_selectionModel.addSelectionInterval(colIndex, colIndex);
            return;
          }
          // unselect the clicked column is alrealdy selected
          if (col_selectionModel.isSelectedIndex(colIndex))
            col_selectionModel.removeSelectionInterval(colIndex, colIndex);
          // else reset column selection and select clicked column
          else
          {
            col_selectionModel.clearSelection();
            col_selectionModel.addSelectionInterval(colIndex, colIndex);
          }
        }
        // manage popup call
        if (e.getButton() == MouseEvent.BUTTON3 && e.getClickCount() == 1)
        {
          // if clicked column is not selected set it as unique selection
          if (!col_selectionModel.isSelectedIndex(colIndex))
          {
            col_selectionModel.clearSelection();
            col_selectionModel.addSelectionInterval(colIndex, colIndex);
          }
          // set menu item enable state
          col_character.setEnabled(isEditable);
          col_numeric.setEnabled(isEditable);
          col_rename.setEnabled(isEditable);
          col_insert.setEnabled(isEditable);
          col_delete.setEnabled(isEditable);
          // set column type menu on current selection
          int[] selected_cols = getSelectedColumns();
          if (selected_cols.length == 1)
          {
            // if single column is selected show its type
            col_character.setSelected(table.getColumnType(selected_cols[0])
                    == DataType.CHARACTER);
            col_numeric.setSelected(table.getColumnType(selected_cols[0])
                    == DataType.NUMERIC);
          } else
          {
            // for multiple selection let both unselected
            col_character.setSelected(false);
            col_numeric.setSelected(false);
          }
          // show the column popup
          cols_PopUp.show(main_table.getTableHeader(), e.getX(), e.getY());
        }

      }

      /**
       * Method not implemented.
       */
      @Override
      public void mousePressed(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseReleased(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseEntered(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseExited(MouseEvent e) {
      }
    });
  }

  /**
   * Initializes the scroll pane.
   */
  private void initScrollPane() {
    // initialize viewport to layout row table
    JViewport row_view = new JViewport() {
      /**
       * Override getPreferredSize in order to allow proper scrolling.
       */
      @Override
      public Dimension getPreferredSize() {
        return row_table.getPreferredSize();
      }
    };
    row_view.setView(row_table);
    // set scrollpane components
    scrollPane.setRowHeaderView(row_view);
    scrollPane.setViewportView(main_table);
    // set the row header behaviour upon mouse input
    scrollPane.getRowHeader().addMouseListener(new MouseListener() {
      /**
       * Handles row addition at the end of the table. By double left-click on
       * row header a new row is added at the end of the table. Pressing CTRL
       * key allow for multiple row addition.
       */
      @Override
      public void mouseClicked(MouseEvent e) {
        // manage row addition at the end of the table
        if (isEditable && e.getButton() == MouseEvent.BUTTON1
                && e.getClickCount() == 2)
        {
          // get number of rows to be inserted
          int rowNumber = 1;
          // check if control is pressed to add more rows at once
          if (e.getModifiersEx() == MouseEvent.CTRL_DOWN_MASK)
          {
            try
            {
              // ask for row number and check it is positive
              rowNumber = Integer.parseInt(JOptionPane.showInputDialog(
                      scrollPane, "Insert number of rows to be added",
                      "Add rows...", JOptionPane.QUESTION_MESSAGE));
              if (rowNumber <= 0) throw new NumberFormatException();
            } catch (NumberFormatException ex)
            {
              JOptionPane.showMessageDialog(scrollPane,
                      "You must insert a positive integer number.",
                      "Validation error", JOptionPane.ERROR_MESSAGE);
              return;
            }
          }
          // add row to Table object
          table.addRows(rowNumber);
          // update row and main table models
          int lastRow = table.rows() - rowNumber;
          RowTableModel row_model = (RowTableModel) row_table.getModel();
          MainTableModel main_model = (MainTableModel) main_table.getModel();
          row_model.fireTableRowsInserted(lastRow, table.rows() - 1);
          main_model.fireTableRowsInserted(lastRow, table.rows() - 1);
        }

      }

      /**
       * Method not implemented.
       */
      @Override
      public void mousePressed(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseReleased(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseEntered(MouseEvent e) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void mouseExited(MouseEvent e) {
      }
    });
  }

  /**
   * Initializes the tool bar.
   */
  private void initToolBar() {
    // TODO: to be implemented.
  }

  /**
   * Initializes the lateral panel.
   */
  private void initLateralPane() {
    // initialize lateral pane width
    lateralPaneWidth = 100;
    // set model and selection model of columns list
    listColumns.setSelectionModel(col_selectionModel);
    listColumns.setModel(new ListModel() {
      /**
       * Returns the number of columns in the Table object.
       */
      @Override
      public int getSize() {
        return table.columns();
      }

      /**
       * Returns the column name at index-th position. The method is not
       * actually used to generate and output. The element content is rendered
       * through ListCellRenderer.
       */
      @Override
      public Object getElementAt(int index) {
        return null;
      }

      /**
       * Method not implemented.
       */
      @Override
      public void addListDataListener(ListDataListener l) {
      }

      /**
       * Method not implemented.
       */
      @Override
      public void removeListDataListener(ListDataListener l) {
      }
    });
    listColumns.setSelectionModel(col_selectionModel);
    // initialize default cell renderer of columns list
    listColumns.setCellRenderer(new ListCellRenderer() {
      /**
       * The element of columns list is formatted. The formatting uses list
       * index to point to index-th column in the table object, and selection
       * state to render background.
       */
      @Override
      public Component getListCellRendererComponent(
              JList list, Object value, int index,
              boolean isSelected, boolean cellHasFocus) {
        // create new label to represent list element
        JLabel element = new JLabel();
        element.setOpaque(true);
        // set label text with column name
        element.setText(table.getColumnName(index));
        // set icon based on column type
        String iconURL = new String();
        switch (table.getColumnType(index))
        {
          case CHARACTER:
            iconURL = "/stats/gui/images/character.png";
            break;
          case NUMERIC:
            iconURL = "/stats/gui/images/numeric.png";
            break;
          case UNDEFINED:
          default:
        }
        element.setIconTextGap(7);
        element.setIcon(new ImageIcon(getClass().getResource(iconURL)));
        // set background based on selection
        element.setForeground(cell_forecolor);
        if (isSelected) element.setBackground(cell_selected_color);
        else element.setBackground(list.getBackground());
        // return the newly created label
        return element;
      }
    });
  }

}
